// ============================================================================
// ShareManager - Social Sharing & Export
// ============================================================================

import { StatisticsCalculators, StatDescriptions } from './stats-calculators.js';

class ShareManager {
    constructor(storageManager, statisticsTracker, seasonManager) {
        this.storage = storageManager;
        this.tracker = statisticsTracker;
        this.seasonManager = seasonManager;
    }

    // Generate shareable image from statistics
    async generateStatsImage(statsType, category = null, subcategory = null, calculatorIds = null, options = {}) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 1200;
        canvas.height = 1600;
        
        // Background
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Header gradient
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop(0, '#2196F3');
        gradient.addColorStop(1, '#1976D2');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, 200);
        
        // Title
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('FC 25 Score Tracker', canvas.width / 2, 80);
        
        // Stats type subtitle
        ctx.font = '32px Arial';
        const typeLabels = {
            'today': 'Today\'s Statistics',
            'season': `Season ${this.seasonManager.getCurrentSeason()} Statistics`,
            'overall': 'Overall Statistics',
            'custom': options.customLabel || 'Custom Statistics'
        };
        ctx.fillText(typeLabels[statsType] || 'Statistics', canvas.width / 2, 140);
        
        // Date
        ctx.font = '24px Arial';
        ctx.fillText(new Date().toLocaleDateString(), canvas.width / 2, 180);
        
        // Get statistics
        let stats;
        if (statsType === 'today') {
            stats = this.tracker.getTodayStats();
        } else if (statsType === 'season') {
            stats = this.tracker.getSeasonStats(this.seasonManager.getCurrentSeason());
        } else if (statsType === 'custom') {
            const matches = options.customMatches || [];
            stats = this.tracker.calculateStatistics(matches, 'custom');
        } else {
            stats = this.tracker.getOverallStats();
        }
        
        // Draw statistics
        let yPos = 280;
        ctx.fillStyle = '#212121';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'left';
        
        // Get calculators
        let calculators;
        if (category && subcategory) {
            calculators = StatisticsCalculators.getBySubcategory(category, subcategory);
        } else if (category) {
            calculators = StatisticsCalculators.getByCategory(category);
        } else {
            calculators = StatisticsCalculators.getAll();
        }
        if (calculatorIds && calculatorIds.length > 0) {
            calculators = calculators
                .filter(calc => calculatorIds.includes(calc.id))
                .sort((a, b) => calculatorIds.indexOf(a.id) - calculatorIds.indexOf(b.id));
        }
        
        calculators.forEach(calculator => {
            const data = stats[calculator.id];
            if (data && Object.keys(data).length > 0) {
                // Category title
                ctx.font = 'bold 32px Arial';
                ctx.fillStyle = '#2196F3';
                ctx.fillText(calculator.name, 60, yPos);
                yPos += 50;
                
                // Draw stats based on calculator type
                if (calculator.id === 'league-table') {
                    this.drawLeagueTable(ctx, data, yPos, canvas.width - 120);
                    yPos += (data.length * 60) + 40;
                } else {
                    // Draw individual stats
                    ctx.font = '28px Arial';
                    ctx.fillStyle = '#212121';
                    Object.entries(data).slice(0, 10).forEach(([key, value]) => {
                        if (yPos > canvas.height - 100) return;
                        ctx.fillText(`${key}: ${value}`, 80, yPos);
                        yPos += 45;
                    });
                    yPos += 20;
                }
            }
        });
        
        // Footer
        ctx.fillStyle = '#757575';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Generated by FC 25 Score Tracker', canvas.width / 2, canvas.height - 40);
        
        return canvas.toDataURL('image/png');
    }

    drawLeagueTable(ctx, data, startY, width) {
        const rowHeight = 50;
        const colWidth = width / 6;
        let y = startY;
        
        // Header
        ctx.fillStyle = '#2196F3';
        ctx.fillRect(60, y, width, rowHeight);
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        const headers = ['Pos', 'Player', 'W', 'L', 'D', 'Pts'];
        headers.forEach((header, i) => {
            ctx.fillText(header, 60 + (i * colWidth) + (colWidth / 2), y + 35);
        });
        
        y += rowHeight;
        
        // Rows
        ctx.fillStyle = '#212121';
        ctx.font = '22px Arial';
        data.slice(0, 8).forEach((row, index) => {
            if (index === 0) {
                ctx.fillStyle = '#4CAF50';
            } else {
                ctx.fillStyle = index % 2 === 0 ? '#F5F5F5' : '#FFFFFF';
            }
            ctx.fillRect(60, y, width, rowHeight);
            
            ctx.fillStyle = '#212121';
            ctx.textAlign = 'center';
            ctx.fillText((index + 1).toString(), 60 + (colWidth / 2), y + 35);
            ctx.textAlign = 'left';
            ctx.fillText(row.player || row.name || 'Unknown', 60 + colWidth + 10, y + 35);
            ctx.textAlign = 'center';
            ctx.fillText((row.wins || 0).toString(), 60 + (colWidth * 2) + (colWidth / 2), y + 35);
            ctx.fillText((row.losses || 0).toString(), 60 + (colWidth * 3) + (colWidth / 2), y + 35);
            ctx.fillText((row.draws || 0).toString(), 60 + (colWidth * 4) + (colWidth / 2), y + 35);
            ctx.fillText((row.points || 0).toString(), 60 + (colWidth * 5) + (colWidth / 2), y + 35);
            
            y += rowHeight;
        });
    }

    // Generate shareable image from match result
    async generateMatchImage(match) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1200;
        canvas.height = 800;
        
        // Background gradient
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#2196F3');
        gradient.addColorStop(1, '#1976D2');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // White content area
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(50, 50, canvas.width - 100, canvas.height - 100);
        
        // Title
        ctx.fillStyle = '#2196F3';
        ctx.font = 'bold 42px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Match Result', canvas.width / 2, 150);
        
        // Teams
        const team1Players = Array.isArray(match.team1) ? match.team1 : [match.team1];
        const team2Players = Array.isArray(match.team2) ? match.team2 : [match.team2];
        const team1Display = team1Players.join(' & ');
        const team2Display = team2Players.join(' & ');
        
        ctx.fillStyle = '#212121';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(team1Display, canvas.width / 2, 280);
        
        // Score
        ctx.fillStyle = '#2196F3';
        ctx.font = 'bold 72px Arial';
        ctx.fillText(`${match.team1Score || 0} - ${match.team2Score || 0}`, canvas.width / 2, 400);
        
        ctx.fillStyle = '#212121';
        ctx.font = 'bold 36px Arial';
        ctx.fillText(team2Display, canvas.width / 2, 500);
        
        // Date
        const date = new Date(match.timestamp);
        ctx.fillStyle = '#757575';
        ctx.font = '24px Arial';
        ctx.fillText(date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }), canvas.width / 2, 600);
        
        // Footer
        ctx.fillStyle = '#757575';
        ctx.font = '20px Arial';
        ctx.fillText('FC 25 Score Tracker', canvas.width / 2, canvas.height - 80);
        
        return canvas.toDataURL('image/png');
    }

    // Export leaderboard as PDF
    async exportLeaderboardPDF(statsType, category = null, subcategory = null, calculatorIds = null, options = {}) {
        // Check if jsPDF is available
        if (typeof window.jspdf === 'undefined') {
            // Try to load jsPDF from CDN if not already loaded
            try {
                await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
            } catch (error) {
                throw new Error('Failed to load PDF library. Please check your internet connection.');
            }
        }
        
        if (typeof window.jspdf === 'undefined') {
            throw new Error('PDF library not available. Please refresh the page and try again.');
        }
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'mm', 'a4');
        
        // ============================================================================
        // PDF Design Constants and Helpers - Sports Theme
        // ============================================================================
        
        // Color Palette (RGB values)
        const COLORS = {
            primary: [33, 150, 243],      // Blue - Performance stats
            goals: [76, 175, 80],         // Green - Goals stats
            league: [255, 152, 0],        // Orange/Gold - League table
            records: [244, 67, 54],       // Red - Records
            general: [156, 39, 176],      // Purple - General
            success: [76, 175, 80],       // Green - Positive values
            danger: [244, 67, 54],        // Red - Negative values
            warning: [255, 152, 0],       // Orange - Warnings
            text: [33, 33, 33],           // Dark text
            textSecondary: [117, 117, 117], // Gray text
            background: [245, 245, 245],   // Light gray for alternating rows
            border: [224, 224, 224]       // Border gray
        };
        
        // Section icons (text symbols that work in PDFs)
        const ICONS = {
            performance: '*',
            goals: '*',
            league: '*',
            records: '*',
            general: '*',
            trend: '*',
            h2h: '*',
            form: '*'
        };
        
        // Get section color based on calculator category
        const getSectionColor = (calculator) => {
            const category = calculator.category || 'performance';
            switch(category) {
                case 'performance': return COLORS.primary;
                case 'goals': return COLORS.goals;
                case 'league': return COLORS.league;
                case 'records': return COLORS.records;
                default: return COLORS.general;
            }
        };
        
        // Get section icon
        const getSectionIcon = (calculator) => {
            const id = calculator.id || '';
            if (id.includes('league') || id.includes('Points')) return ICONS.league;
            if (id.includes('goal') || id.includes('Goals')) return ICONS.goals;
            if (id.includes('trend') || id.includes('Trend')) return ICONS.trend;
            if (id.includes('headToHead') || id.includes('Head')) return ICONS.h2h;
            if (id.includes('form') || id.includes('Form')) return ICONS.form;
            if (id.includes('record') || id.includes('Record')) return ICONS.records;
            return ICONS.performance;
        };
        
        // Get player color from settings (if available)
        const getPlayerColor = (playerName) => {
            try {
                if (window.appController && window.appController.settingsManager) {
                    const color = window.appController.settingsManager.getPlayerColor(playerName);
                    if (color) {
                        // Convert hex to RGB array
                        const hex = color.replace('#', '');
                        return [
                            parseInt(hex.substr(0, 2), 16),
                            parseInt(hex.substr(2, 2), 16),
                            parseInt(hex.substr(4, 2), 16)
                        ];
                    }
                }
            } catch (e) {
                // Ignore errors
            }
            return null;
        };
        
        // Format number with color coding
        const formatNumber = (value, type = 'neutral') => {
            if (type === 'positive') return { text: String(value), color: COLORS.success };
            if (type === 'negative') return { text: String(value), color: COLORS.danger };
            return { text: String(value), color: COLORS.text };
        };
        
        // Get statistics
        let stats;
        let title;
        if (statsType === 'today') {
            stats = this.tracker.getTodayStats();
            title = 'Today\'s Statistics';
        } else if (statsType === 'season') {
            stats = this.tracker.getSeasonStats(this.seasonManager.getCurrentSeason());
            title = `Season ${this.seasonManager.getCurrentSeason()} Statistics`;
        } else if (statsType === 'custom') {
            const matches = options.customMatches || [];
            stats = this.tracker.calculateStatistics(matches, 'custom');
            title = options.customLabel || 'Custom Statistics';
        } else {
            stats = this.tracker.getOverallStats();
            title = 'Overall Statistics';
        }
        
        // Enhanced helper function to draw a table with colors and styling
        const drawTable = (headers, rows, startY, colWidths, headerColor = [33, 150, 243], options = {}) => {
            let currentY = startY;
            const pageWidth = 210;
            const margin = 15;
            const tableWidth = pageWidth - (margin * 2);
            const rowHeight = 6; // Increased row height for better spacing
            
            // Draw header background with border
            doc.setFillColor(...headerColor);
            doc.rect(margin, currentY - 6, tableWidth, rowHeight + 1, 'F');
            
            // Draw header border
            doc.setDrawColor(...COLORS.border);
            doc.setLineWidth(0.1);
            doc.rect(margin, currentY - 6, tableWidth, rowHeight + 1);
            
            // Draw header text
            doc.setFontSize(9);
            doc.setTextColor(255, 255, 255);
            doc.setFont(undefined, 'bold');
            let xPos = margin + 2;
            headers.forEach((header, i) => {
                doc.text(header, xPos, currentY);
                xPos += colWidths[i];
            });
            
            currentY += rowHeight;
            
            // Draw rows
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');
            
            rows.forEach((row, rowIndex) => {
                // Check if we need a new page
                if (currentY > 270) {
                    doc.addPage();
                    currentY = 20;
                    // Redraw header on new page
                    doc.setFillColor(...headerColor);
                    doc.rect(margin, currentY - 6, tableWidth, rowHeight + 1, 'F');
                    doc.setDrawColor(...COLORS.border);
                    doc.rect(margin, currentY - 6, tableWidth, rowHeight + 1);
                    doc.setFontSize(9);
                    doc.setTextColor(255, 255, 255);
                    doc.setFont(undefined, 'bold');
                    xPos = margin + 2;
                    headers.forEach((header, i) => {
                        doc.text(header, xPos, currentY);
                        xPos += colWidths[i];
                    });
                    currentY += rowHeight;
                    doc.setFontSize(8);
                    doc.setFont(undefined, 'normal');
                }
                
                // Position-based highlighting (top 3)
                const position = rowIndex + 1;
                let rowBgColor = null;
                if (position === 1) {
                    rowBgColor = [255, 248, 220]; // Light gold for 1st
                } else if (position === 2) {
                    rowBgColor = [245, 245, 245]; // Silver gray for 2nd
                } else if (position === 3) {
                    rowBgColor = [255, 235, 205]; // Light bronze for 3rd
                } else if (rowIndex % 2 === 0) {
                    rowBgColor = COLORS.background; // Alternating rows
                }
                
                // Draw row background
                if (rowBgColor) {
                    doc.setFillColor(...rowBgColor);
                    doc.rect(margin, currentY - 5, tableWidth, rowHeight, 'F');
                }
                
                // Draw row border
                doc.setDrawColor(...COLORS.border);
                doc.setLineWidth(0.05);
                doc.rect(margin, currentY - 5, tableWidth, rowHeight);
                
                // Draw row text with smart formatting
                xPos = margin + 2;
                row.forEach((cell, i) => {
                    let cellText = String(cell || '').substring(0, 25);
                    let cellColor = COLORS.text;
                    
                    // Smart color coding based on cell content
                    const headerName = headers[i] || '';
                    
                    if (cellText.startsWith('-') || cellText.startsWith('+')) {
                        const num = parseFloat(cellText);
                        if (!isNaN(num)) {
                            cellColor = num >= 0 ? COLORS.success : COLORS.danger;
                        }
                    } else if (i === 0 && cellText.match(/^[1-3]$/)) {
                        // Position numbers - bold for top 3
                        doc.setFont(undefined, 'bold');
                    } else if (headerName.includes('W') && !headerName.includes('Win %')) {
                        // Win columns - green for wins
                        const num = parseFloat(cellText);
                        if (!isNaN(num) && num > 0) {
                            cellColor = COLORS.success;
                        }
                    } else if (headerName.includes('L') && !headerName.includes('Loss')) {
                        // Loss columns - red for losses
                        const num = parseFloat(cellText);
                        if (!isNaN(num) && num > 0) {
                            cellColor = COLORS.danger;
                        }
                    } else if (cellText.includes('%')) {
                        // Percentage values
                        const num = parseFloat(cellText);
                        if (!isNaN(num)) {
                            if (num >= 70) cellColor = COLORS.success;
                            else if (num >= 50) cellColor = COLORS.text;
                            else if (num >= 30) cellColor = COLORS.warning;
                            else cellColor = COLORS.danger;
                        }
                    } else if (headerName.includes('GF') || headerName.includes('Goals') || headerName.includes('Goals For')) {
                        // Goals for - green
                        const num = parseFloat(cellText);
                        if (!isNaN(num) && num > 0) {
                            cellColor = COLORS.success;
                        }
                    } else if (headerName.includes('GA') || headerName.includes('Goals Against')) {
                        // Goals against - neutral/red for high values
                        const num = parseFloat(cellText);
                        if (!isNaN(num)) {
                            cellColor = COLORS.text;
                        }
                    } else if (headerName.includes('Win') || headerName.includes('Wins')) {
                        // Win-related columns
                        const num = parseFloat(cellText);
                        if (!isNaN(num) && num > 0) {
                            cellColor = COLORS.success;
                        }
                    }
                    
                    // Apply player color and bold for player names
                    if (i === 1 && headers[i] === 'Player') {
                        // Always bold player names for readability
                        doc.setFont(undefined, 'bold');
                        
                        // Use player color if available (especially for top 3)
                        if (options.highlightPlayerNames && position <= 3) {
                            const playerColor = getPlayerColor(cellText);
                            if (playerColor) {
                                cellColor = playerColor;
                            }
                        }
                    }
                    
                    doc.setTextColor(...cellColor);
                    doc.text(cellText, xPos, currentY);
                    xPos += colWidths[i];
                    
                    // Reset font
                    doc.setFont(undefined, 'normal');
                });
                
                // Reset text color
                doc.setTextColor(...COLORS.text);
                
                currentY += rowHeight;
            });
            
            return currentY + 5; // Extra spacing after table
        };
        
        // Enhanced Header with gradient background effect
        const headerHeight = 25;
        const headerY = 10;
        
        // Draw header background (simulated gradient with rectangle)
        doc.setFillColor(...COLORS.primary);
        doc.rect(0, headerY, 210, headerHeight, 'F');
        
        // Draw a darker shade at the bottom for depth
        doc.setFillColor(COLORS.primary[0] - 20, COLORS.primary[1] - 20, COLORS.primary[2] - 20);
        doc.rect(0, headerY + headerHeight - 2, 210, 2, 'F');
        
        // Main title
        doc.setFontSize(22);
        doc.setTextColor(255, 255, 255);
        doc.setFont(undefined, 'bold');
        doc.text('FC 25 Score Tracker', 105, headerY + 10, { align: 'center' });
        
        // Subtitle
        doc.setFontSize(12);
        doc.setTextColor(255, 255, 255);
        doc.setFont(undefined, 'normal');
        doc.text(title, 105, headerY + 17, { align: 'center' });
        
        // Date below header
        doc.setFontSize(9);
        doc.setTextColor(...COLORS.textSecondary);
        doc.text(new Date().toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        }), 105, headerY + headerHeight + 5, { align: 'center' });
        
        let yPos = headerY + headerHeight + 12;
        
        // Get calculators
        let calculators;
        if (category && subcategory) {
            calculators = StatisticsCalculators.getBySubcategory(category, subcategory);
        } else if (category) {
            calculators = StatisticsCalculators.getByCategory(category);
        } else {
            calculators = StatisticsCalculators.getAll();
        }
        if (calculatorIds && calculatorIds.length > 0) {
            calculators = calculators
                .filter(calc => calculatorIds.includes(calc.id))
                .sort((a, b) => calculatorIds.indexOf(a.id) - calculatorIds.indexOf(b.id));
        }
        
        calculators.forEach(calculator => {
            // Skip visualization calculators (charts) that don't work well in PDF
            if (calculator.id === 'winRateChart' || calculator.id === 'goalsChart') {
                return;
            }
            
            const data = stats[calculator.id];
            if (data && Object.keys(data).length > 0) {
                // Check if we need a new page - add more space before new sections
                if (yPos > 240) {
                    doc.addPage();
                    yPos = 20;
                } else {
                    // Add spacing before new section
                    yPos += 3;
                }
                
                // Enhanced section title with color-coded header
                const sectionColor = getSectionColor(calculator);
                
                // Draw section background bar
                doc.setFillColor(...sectionColor);
                doc.rect(15, yPos - 4, 180, 6, 'F');
                
                // Section title (bold, white on colored background)
                doc.setFontSize(13);
                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
                doc.text(calculator.name, 18, yPos);
                
                yPos += 10;
                
                // Sort entries based on calculator type
                let sortedEntries = Object.entries(data);
                if (calculator.id === 'totalGoals') {
                    sortedEntries = sortedEntries.sort((a, b) => (b[1].goals || 0) - (a[1].goals || 0));
                } else if (calculator.id === 'goalDifference') {
                    sortedEntries = sortedEntries.sort((a, b) => (b[1].goalDifference || 0) - (a[1].goalDifference || 0));
                } else if (calculator.id === 'avgGoalsPerGame') {
                    sortedEntries = sortedEntries.sort((a, b) => parseFloat(b[1].avgGoals || 0) - parseFloat(a[1].avgGoals || 0));
                } else if (calculator.id === 'winLossDraw') {
                    sortedEntries = sortedEntries.sort((a, b) => {
                        if (b[1].games !== a[1].games) {
                            return b[1].games - a[1].games;
                        }
                        return b[1].wins - a[1].wins;
                    });
                } else if (calculator.id === 'winRate') {
                    sortedEntries = sortedEntries.sort((a, b) => {
                        const rateA = parseFloat(a[1].winRate || 0);
                        const rateB = parseFloat(b[1].winRate || 0);
                        if (rateB !== rateA) {
                            return rateB - rateA;
                        }
                        return b[1].games - a[1].games;
                    });
                } else if (calculator.id === 'streak') {
                    sortedEntries = sortedEntries.sort((a, b) => (b[1].currentStreak || 0) - (a[1].currentStreak || 0));
                } else if (calculator.id === 'form') {
                    // Form: sort by points (configurable)
                    sortedEntries = sortedEntries.sort((a, b) => {
                        const pointsA = Number.isFinite(b[1].points) ? b[1].points : ((b[1].wins || 0) + (b[1].draws || 0));
                        const pointsB = Number.isFinite(a[1].points) ? a[1].points : ((a[1].wins || 0) + (a[1].draws || 0));
                        return pointsA - pointsB;
                    });
                } else if (calculator.id === 'leaguePoints') {
                    // League: sort by points (configurable)
                    sortedEntries = sortedEntries.sort((a, b) => {
                        const pointsA = (b[1].points || 0);
                        const pointsB = (a[1].points || 0);
                        if (pointsA !== pointsB) return pointsA - pointsB;
                        // Tie-breaker: goal difference
                        const gdA = (b[1].goalDifference || 0);
                        const gdB = (a[1].goalDifference || 0);
                        return gdA - gdB;
                    });
                } else if (calculator.id === 'comparativeStats') {
                    sortedEntries = sortedEntries.sort((a, b) => {
                        const gamesA = (a[1].headToHead && a[1].headToHead.games) || 0;
                        const gamesB = (b[1].headToHead && b[1].headToHead.games) || 0;
                        return gamesB - gamesA; // Sort by games descending
                    });
                }
                
                // Format data into table rows based on calculator type
                let headers = [];
                let rows = [];
                let colWidths = [];
                
                if (calculator.id === 'leaguePoints' || calculator.id === 'league-table') {
                    // League table format
                    headers = ['Pos', 'Player', 'Pts', 'W', 'D', 'L', 'GP'];
                    colWidths = [12, 60, 18, 15, 15, 15, 18];
                    // Helper to format position with medal
                    const formatPosition = (index) => {
                        const pos = index + 1;
                        if (pos === 1) return '1';
                        if (pos === 2) return '2';
                        if (pos === 3) return '3';
                        return pos.toString();
                    };
                    
                    if (Array.isArray(data)) {
                        rows = data.slice(0, 20).map((row, index) => [
                            formatPosition(index),
                            (row.player || row.name || 'Unknown').substring(0, 20),
                            (row.points || 0).toString(),
                            (row.wins || 0).toString(),
                            (row.draws || 0).toString(),
                            (row.losses || 0).toString(),
                            (row.games || 0).toString()
                        ]);
                    } else {
                        rows = sortedEntries.slice(0, 20).map(([player, stats], index) => [
                            formatPosition(index),
                            player.substring(0, 20),
                            (stats.points || 0).toString(),
                            (stats.wins || 0).toString(),
                            (stats.draws || 0).toString(),
                            (stats.losses || 0).toString(),
                            (stats.games || 0).toString()
                        ]);
                    }
                } else if (calculator.id === 'totalGoals') {
                    headers = ['Pos', 'Player', 'Goals'];
                    colWidths = [12, 120, 30];
                    rows = sortedEntries.slice(0, 20).map(([player, stats], index) => [
                        (index + 1).toString(),
                        player.substring(0, 25),
                        (stats.goals || 0).toString()
                    ]);
                } else if (calculator.id === 'goalDifference') {
                    headers = ['Pos', 'Player', 'GD', 'GF', 'GA'];
                    colWidths = [12, 80, 20, 20, 20];
                    rows = sortedEntries.slice(0, 20).map(([player, stats], index) => {
                        const pos = index + 1;
                        const gd = stats.goalDifference || 0;
                        const gdText = gd > 0 ? `+${gd}` : gd.toString();
                        return [
                            pos.toString(),
                            player.substring(0, 20),
                            gdText,
                            (stats.goalsFor || 0).toString(),
                            (stats.goalsAgainst || 0).toString()
                        ];
                    });
                } else if (calculator.id === 'avgGoalsPerGame') {
                    headers = ['Pos', 'Player', 'Avg', 'GF', 'GP'];
                    colWidths = [12, 80, 25, 25, 25];
                    rows = sortedEntries.slice(0, 20).map(([player, stats], index) => [
                        (index + 1).toString(),
                        player.substring(0, 20),
                        (stats.avgGoals || 0).toString(),
                        (stats.totalGoals || 0).toString(),
                        (stats.games || 0).toString()
                    ]);
                } else if (calculator.id === 'winLossDraw') {
                    headers = ['Pos', 'Player', 'GP', 'W', 'D', 'L'];
                    colWidths = [12, 80, 20, 20, 20, 20];
                    rows = sortedEntries.slice(0, 20).map(([player, stats], index) => [
                        (index + 1).toString(),
                        player.substring(0, 20),
                        (stats.games || 0).toString(),
                        (stats.wins || 0).toString(),
                        (stats.draws || 0).toString(),
                        (stats.losses || 0).toString()
                    ]);
                } else if (calculator.id === 'winRate') {
                    headers = ['Pos', 'Player', 'Win %', 'GP'];
                    colWidths = [12, 100, 30, 30];
                    rows = sortedEntries.slice(0, 20).map(([player, stats], index) => [
                        (index + 1).toString(),
                        player.substring(0, 25),
                        `${(stats.winRate || 0)}%`,
                        (stats.games || 0).toString()
                    ]);
                } else if (calculator.id === 'streak') {
                    headers = ['Pos', 'Player', 'Streak', 'Type'];
                    colWidths = [12, 100, 25, 35];
                    rows = sortedEntries.slice(0, 20).map(([player, stats], index) => {
                        const streakType = stats.streakType === 'win' ? 'Wins' : stats.streakType === 'loss' ? 'Losses' : 'None';
                        return [
                            (index + 1).toString(),
                            player.substring(0, 25),
                            (stats.currentStreak || 0).toString(),
                            streakType
                        ];
                    });
                } else if (calculator.id === 'form') {
                    headers = ['Pos', 'Player', 'Form', 'W', 'D', 'L', 'Pts'];
                    colWidths = [12, 70, 25, 15, 15, 15, 20];
                    rows = sortedEntries.slice(0, 20).map(([player, stats], index) => {
                        const formStr = (stats.form || []).slice(-5).map(f => f === 'W' ? 'W' : f === 'D' ? 'D' : 'L').join('');
                        const points = Number.isFinite(stats.points) ? stats.points : (stats.wins || 0) + (stats.draws || 0);
                        return [
                            (index + 1).toString(),
                            player.substring(0, 18),
                            formStr || 'N/A',
                            (stats.wins || 0).toString(),
                            (stats.draws || 0).toString(),
                            (stats.losses || 0).toString(),
                            points.toString()
                        ];
                    });
                } else if (calculator.id === 'worstLosses') {
                    headers = ['Player', 'Best Win', 'Worst Loss'];
                    colWidths = [50, 65, 65];
                    rows = sortedEntries.slice(0, 15).map(([player, stats]) => {
                        const bestWin = stats.bestByGoalsFor ? stats.bestByGoalsFor.score : '-';
                        const worstLoss = stats.worstByGoalsAgainst ? stats.worstByGoalsAgainst.score : '-';
                        return [
                            player.substring(0, 20),
                            bestWin,
                            worstLoss
                        ];
                    });
                } else if (calculator.id === 'headToHead') {
                    headers = ['Players', 'Together (W-D-L)', 'Against (W-D-L)'];
                    colWidths = [60, 50, 50];
                    rows = sortedEntries.slice(0, 15).map(([pair, stats]) => {
                        const together = stats.together || {};
                        const against = stats.against || {};
                        return [
                            pair.substring(0, 20),
                            `${together.wins || 0}-${together.draws || 0}-${together.losses || 0}`,
                            `${against.wins || 0}-${against.draws || 0}-${against.losses || 0}`
                        ];
                    });
                } else if (calculator.id === 'insights' || calculator.id === 'performanceInsights') {
                    // Skip insights - they're text-based and don't format well in PDF tables
                    return;
                } else if (calculator.id === 'winRateChart' || calculator.id === 'goalsChart') {
                    // Skip chart calculators
                    return;
                } else if (calculator.id === 'trendAnalysis') {
                    // Format trend analysis better - use plain text instead of Unicode arrows for PDF compatibility
                    headers = ['Player', 'Trend', 'Strength'];
                    colWidths = [80, 60, 40];
                    rows = sortedEntries.slice(0, 20).map(([player, stats]) => {
                        const trend = stats.trend || 'stable';
                        const strength = (stats.trendStrength !== undefined && stats.trendStrength !== null) 
                            ? `${Math.round(stats.trendStrength)}%` 
                            : '-';
                        // Use plain text instead of Unicode arrows for better PDF compatibility
                        const trendText = trend === 'improving_strong' ? 'Strong Up' :
                                        trend === 'improving' ? 'Improving' :
                                        trend === 'declining_strong' ? 'Strong Down' :
                                        trend === 'declining' ? 'Declining' : 'Stable';
                        return [
                            player.substring(0, 20),
                            trendText,
                            strength
                        ];
                    });
                } else if (calculator.id === 'comparativeStats') {
                    // Format player comparison
                    headers = ['Players', 'P1 Win %', 'P2 Win %', 'Games'];
                    colWidths = [70, 30, 30, 30];
                    rows = sortedEntries.slice(0, 15).map(([pair, stats]) => {
                        const headToHead = stats.headToHead || {};
                        const p1Rate = headToHead.p1WinRate !== undefined && headToHead.games > 0 
                            ? `${headToHead.p1WinRate.toFixed(1)}%` 
                            : '-';
                        const p2Rate = headToHead.p2WinRate !== undefined && headToHead.games > 0 
                            ? `${headToHead.p2WinRate.toFixed(1)}%` 
                            : '-';
                        const games = headToHead.games || 0;
                        return [
                            pair.substring(0, 20),
                            p1Rate,
                            p2Rate,
                            games.toString()
                        ];
                    });
                } else if (calculator.id === 'activityHeatmap' || calculator.id === 'matchDistribution') {
                    // Skip these - they're visualization/data structures
                    return;
                } else if (calculator.id === 'extraTimePenalties') {
                    // Format extra time and penalties
                    headers = ['Player', 'Matches', 'Extra Time', 'Penalties'];
                    colWidths = [60, 30, 40, 40];
                    rows = sortedEntries.slice(0, 20).map(([player, stats]) => {
                        const matches = stats.totalMatches || 0;
                        const extraTime = stats.extraTimeMatches || 0;
                        const penalties = stats.penaltyMatches || 0;
                        return [
                            player.substring(0, 20),
                            matches.toString(),
                            extraTime.toString(),
                            penalties.toString()
                        ];
                    });
                } else {
                    // Generic table for other stats - format better
                    headers = ['Player', 'Details'];
                    colWidths = [80, 100];
                    rows = sortedEntries.slice(0, 20).map(([player, stats]) => {
                        let value = '';
                        if (typeof stats === 'object') {
                            // Format common stat fields nicely
                            if (stats.goalsFor !== undefined && stats.goalsAgainst !== undefined) {
                                value = `GF: ${stats.goalsFor}, GA: ${stats.goalsAgainst}`;
                            } else if (stats.cumulativeWins !== undefined && stats.cumulativeGames !== undefined) {
                                const winRate = stats.cumulativeGames > 0 
                                    ? ((stats.cumulativeWins / stats.cumulativeGames) * 100).toFixed(1) 
                                    : '0.0';
                                value = `Wins: ${stats.cumulativeWins}, Games: ${stats.cumulativeGames}, Win Rate: ${winRate}%`;
                            } else {
                                // Format other numeric fields
                                const formatted = Object.entries(stats)
                                    .filter(([k, v]) => typeof v === 'number' && !k.includes('Date') && !k.includes('date'))
                                    .slice(0, 3)
                                    .map(([k, v]) => {
                                        const label = k.replace(/([A-Z])/g, ' $1').trim();
                                        return `${label}: ${v}`;
                                    })
                                    .join(', ');
                                value = formatted || 'No data';
                            }
                        } else {
                            value = String(stats);
                        }
                        return [player.substring(0, 25), value.substring(0, 50)];
                    });
                }
                
                if (rows.length > 0) {
                    const sectionColor = getSectionColor(calculator);
                    yPos = drawTable(headers, rows, yPos, colWidths, sectionColor, { highlightPlayerNames: true });
                    
                    // Add description below the table
                    const description = StatDescriptions.getPDFDescription(calculator.id);
                    if (description) {
                        // Check if we need a new page before description
                        if (yPos > 265) {
                            doc.addPage();
                            yPos = 20;
                        }
                        
                        yPos += 4; // Space after table
                        doc.setFontSize(8);
                        doc.setTextColor(...COLORS.textSecondary);
                        doc.setFont(undefined, 'italic');
                        
                        // Split description text to fit page width (180mm = page width minus margins)
                        const splitText = doc.splitTextToSize(description, 180);
                        splitText.forEach((line) => {
                            // Check for new page within description
                            if (yPos > 270) {
                                doc.addPage();
                                yPos = 20;
                            }
                            doc.text(line, 15, yPos);
                            yPos += 4;
                        });
                        yPos += 5; // Extra space before next section
                    }
                }
            }
        });
        
        // Enhanced Footer with page numbers
        const pageCount = doc.internal.pages.length - 1;
        for (let i = 1; i <= pageCount; i++) {
            doc.setPage(i);
            
            // Draw footer line
            doc.setDrawColor(...COLORS.border);
            doc.setLineWidth(0.2);
            doc.line(15, 282, 195, 282);
            
            // Footer text
            doc.setFontSize(8);
            doc.setTextColor(...COLORS.textSecondary);
            doc.setFont(undefined, 'normal');
            doc.text('Generated by FC 25 Score Tracker', 105, 287, { align: 'center' });
            doc.text(`Page ${i} of ${pageCount}`, 105, 292, { align: 'center' });
        }
        
        // Generate PDF blob
        const pdfBlob = doc.output('blob');
        const fileName = `FC25_${statsType}_${new Date().toISOString().split('T')[0]}.pdf`;
        
        // Try mobile-friendly saving methods
        let saved = false;
        
        // Try Web Share API for mobile devices (if File constructor is supported)
        if (navigator.share && typeof File !== 'undefined' && /Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            try {
                // Check if Web Share API supports files
                if (navigator.canShare) {
                    const file = new File([pdfBlob], fileName, { type: 'application/pdf' });
                    const shareData = { files: [file] };
                    if (navigator.canShare(shareData)) {
                        await navigator.share(shareData);
                        saved = true;
                        return { blob: pdfBlob, blobUrl: URL.createObjectURL(pdfBlob), fileName, saved: true };
                    }
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error sharing PDF:', error);
                }
                // Fall through to other methods
            }
        }
        
        // Try File System Access API (mainly for desktop/Chrome)
        if (!saved && 'showSaveFilePicker' in window) {
            try {
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'PDF files',
                        accept: { 'application/pdf': ['.pdf'] }
                    }]
                });
                const writable = await fileHandle.createWritable();
                await writable.write(pdfBlob);
                await writable.close();
                saved = true;
                return { blob: pdfBlob, blobUrl: URL.createObjectURL(pdfBlob), fileName, saved: true };
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error saving PDF via File System API:', error);
                }
                // Fall through to fallback method
            }
        }
        
        // Fallback: Use traditional download (works on all browsers)
        if (!saved) {
            const blobUrl = URL.createObjectURL(pdfBlob);
            const link = document.createElement('a');
            link.href = blobUrl;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            // Don't revoke URL immediately - keep it for viewing
            saved = true;
            return { blob: pdfBlob, blobUrl, fileName, saved: true };
        }
        
        return { blob: pdfBlob, blobUrl: URL.createObjectURL(pdfBlob), fileName, saved: false };
    }

    // Share image via Web Share API or download
    async shareImage(imageDataUrl, fileName) {
        try {
            // Convert data URL to blob
            const response = await fetch(imageDataUrl);
            const blob = await response.blob();
            const file = new File([blob], fileName, { type: 'image/png' });
            
            // Try Web Share API
            if (navigator.share && navigator.canShare({ files: [file] })) {
                await navigator.share({
                    title: 'FC 25 Statistics',
                    text: 'Check out my FC 25 match statistics!',
                    files: [file]
                });
                return true;
            }
        } catch (error) {
            console.log('Web Share API not available or failed:', error);
        }
        
        // Fallback: download image
        this.downloadImage(imageDataUrl, fileName);
        return false;
    }

    // Download image
    downloadImage(imageDataUrl, fileName) {
        const link = document.createElement('a');
        link.download = fileName;
        link.href = imageDataUrl;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // Haptic Feedback Helper
    vibrate(pattern = [50]) {
        if ('vibrate' in navigator) {
            try {
                navigator.vibrate(pattern);
            } catch (e) {
                // Vibration not supported or failed
            }
        }
    }

    // Load external script
    loadScript(src) {
        return new Promise((resolve, reject) => {
            if (document.querySelector(`script[src="${src}"]`)) {
                resolve();
                return;
            }
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
}

export { ShareManager };

